---
title: "GraalVM"
ring: adopt
quadrant: "tools"
tags: [java, backend]
---

The General Recursive Applicative and Algorithmic Language Virtual Machine
(Graal VM) is a high-performance JDK distribution written for Java and other JVM
languages, along with support for JavaScript, Ruby, Python, and several other
languages. It provides a Native Image builder – a tool to build native code from
Java applications and package it together with the VM into a standalone
executable. It is officially supported by the Spring Boot Maven and Gradle
Plugin with a few exceptions.

GraalVM Native Images are standalone executables that can be generated by
processing compiled Java applications ahead-of-time. Native Images generally
have a smaller memory footprint and start faster than their JVM counterparts.
[Spring Boot Native](https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html)

### Key features:

- **Native Images** A native image is a standalone executable that includes the
  application classes, classes from its dependencies, runtime library classes,
  and statically linked native code from JDK. The JVM is packaged into the
  native image, eliminating the need for a Java Runtime Environment at the
  target system.

- **Ahead-of-Time Compilation** GraalVM compiles Java applications ahead of time
  into standalone binaries. These binaries are smaller, start up to 100x faster,
  provide peak performance with no warmup, and use less memory and CPU than
  applications running on a Java Virtual Machine (JVM)12.

- **Reduced Attack Surface** GraalVM reduces the attack surface of your
  application. It excludes unused classes, methods, and fields from the
  application binary. It restricts reflection and other dynamic Java language
  features to build time only. It does not load any unknown code at run time.

- **Support for Microservices Frameworks and Cloud Platforms** Popular
  microservices frameworks such as Spring Boot, Micronaut, Helidon, and Quarkus,
  and cloud platforms such as Oracle Cloud Infrastructure, Amazon Web Services,
  Google Cloud Platform, and Microsoft Azure all support GraalVM.

- **Profile-Guided Optimization and G1 Garbage Collector** With profile-guided
  optimization and the G1 (Garbage-First) garbage collector, you can get lower
  latency and on-par or better peak performance and throughput compared to
  applications running on a JVM.

- **Licensing and Support** GraalVM Community Edition is open-source software
  built from the sources available on GitHub and distributed under version 2 of
  the GNU General Public License with the "Classpath" Exception.

[GraalVM](https://www.graalvm.org/latest/docs/introduction/)

### Enterprise use cases

A lot of companies are using GraalVM as a performance booster
[https://www.graalvm.org/use-cases/](https://www.graalvm.org/use-cases/), for
example Disney use native image compilation to reduce cold startup time of
[AWS lambda](https://aws.amazon.com/it/blogs/opensource/improving-developer-productivity-at-disney-with-serverless-and-open-source/)
based on Java.

### Tips & Tricks

#### Reflection

Native image compilation as some limitations regarding the usage of refelections
cause it need all class information at build time. To solve this issue the
GraalVM community offers the "reachibility metadata" for the most common
libraries. Frameworks like SpringBoot and Quarkus also allows to generate
metadata for reflections by using dedicated API, for example in Spring you can
use
[RuntimeHintsRegistrar](https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.advanced.custom-hints).
When there isn't reachibility metada for a particular library, GraalVM offers an
[agent](https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.advanced.using-the-tracing-agent)
to capture metadata.

#### Frameworks

Spring Boot and Quarkus already supports GraalVM native image by relying on AOT
compiler. There is some "guideline" to follows in order to successfuly get a
running native image:

- Spring Boot:
  https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-with-GraalVM
- Quarkus: https://quarkus.io/guides/writing-native-applications-tips

Also, the adoption of OpenTelemetry as an observability instrumentation tool
over a Java stack based microservice is a key enabler to native image of
microservice. This is due to missing support , by GraalVM native compilation, to
java agents, which is the main way to instrument java microservices.

### Our use cases:

- (https://github.com/pagopa/rtd-ms-sender-auth) The Sender Auth is a µ-service
  responsible to store the association between sender code and api key, and the
  last version was deployed using a GraalVM. It's up and running, and here is
  possible to check the code.

- [cstar-mock-io](https://github.com/pagopa/cstar-io-mock) a microservice which
  generate JWT token for test purposes. It's written using SpringBoot with
  reactive stack.
